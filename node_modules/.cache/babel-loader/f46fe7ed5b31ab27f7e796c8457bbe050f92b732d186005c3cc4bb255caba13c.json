{"ast":null,"code":"export function dfs(grid, start, finish) {\n  const [numRows, numCols] = [grid.length, grid[0].length];\n  const stack = [];\n  const path = [];\n  stack.push(start);\n  console.log(\"Tipo\");\n  console.log(typeof grid);\n  while (stack.length) {\n    const curr = stack.pop();\n    const [i, j] = [curr.row, curr.col];\n    if (curr === finish) {\n      path.push(finish);\n      return path;\n    }\n    if (!curr.isVisited && !curr.isWall) {\n      curr.isVisited = true;\n      path.push(curr);\n      console.log(i, j);\n      // para todos adjacentes ao curr, não visitados, adicione-os a stack\n\n      // baixo\n      if (i + 1 < numRows && !grid[i + 1][j].isVisited && !grid[i + 1][j].isWall) {\n        grid[i + 1][j].previous = curr;\n        stack.push(grid[i + 1][j]);\n      }\n\n      // esquerda\n      if (j - 1 >= 0 && !grid[i][j - 1].isVisited && !grid[i][j - 1].isWall) {\n        grid[i][j - 1].previous = curr;\n        stack.push(grid[i][j - 1]);\n      }\n      // cima\n      if (i - 1 >= 0 && !grid[i - 1][j].isVisited && !grid[i - 1][j].isWall) {\n        grid[i - 1][j].previous = curr;\n        stack.push(grid[i - 1][j]);\n      }\n\n      // direita\n      if (j + 1 < numCols && !grid[i][j + 1].isVisited && !grid[i][j + 1].isWall) {\n        grid[i][j + 1].previous = curr;\n        stack.push(grid[i][j + 1]);\n      }\n    }\n  }\n  return [];\n}","map":{"version":3,"names":["dfs","grid","start","finish","numRows","numCols","length","stack","path","push","console","log","curr","pop","i","j","row","col","isVisited","isWall","previous"],"sources":["/home/renato/Documents/code-canvas/src/algorithms/dfs.js"],"sourcesContent":["export function dfs(grid, start, finish) {\n  const [numRows, numCols] = [grid.length, grid[0].length];\n  const stack = [];\n  const path = [];\n\n  stack.push(start);\n  console.log(\"Tipo\");\n  console.log(typeof grid);\n  while (stack.length) {\n    const curr = stack.pop();\n    const [i, j] = [curr.row, curr.col];\n\n    if (curr === finish) {\n      path.push(finish);\n      return path;\n    }\n\n    if (!curr.isVisited && !curr.isWall) {\n      curr.isVisited = true;\n      path.push(curr);\n      console.log(i, j);\n      // para todos adjacentes ao curr, não visitados, adicione-os a stack\n\n      // baixo\n      if (\n        i + 1 < numRows &&\n        !grid[i + 1][j].isVisited &&\n        !grid[i + 1][j].isWall\n      ) {\n        grid[i + 1][j].previous = curr;\n        stack.push(grid[i + 1][j]);\n      }\n\n      // esquerda\n      if (j - 1 >= 0 && !grid[i][j - 1].isVisited && !grid[i][j - 1].isWall) {\n        grid[i][j - 1].previous = curr;\n        stack.push(grid[i][j - 1]);\n      }\n      // cima\n      if (i - 1 >= 0 && !grid[i - 1][j].isVisited && !grid[i - 1][j].isWall) {\n        grid[i - 1][j].previous = curr;\n        stack.push(grid[i - 1][j]);\n      }\n\n      // direita\n      if (\n        j + 1 < numCols &&\n        !grid[i][j + 1].isVisited &&\n        !grid[i][j + 1].isWall\n      ) {\n        grid[i][j + 1].previous = curr;\n        stack.push(grid[i][j + 1]);\n      }\n    }\n  }\n\n  return [];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}